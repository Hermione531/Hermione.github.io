<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Hermione">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hermione">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hermione">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hermione</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hermione</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/test-my-site/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/test-my-site/" itemprop="url">test_my_site</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-25T22:27:36+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/25/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/25/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-25T22:22:36+08:00">
                2019-02-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/13/React知识点整理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/13/React知识点整理/" itemprop="url">React知识点整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-13T14:56:42+08:00">
                2019-01-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="初入React"><a href="#初入React" class="headerlink" title="初入React"></a>初入React</h2><h4 id="JSX语法"><a href="#JSX语法" class="headerlink" title="JSX语法"></a>JSX语法</h4><ul>
<li>定义标签时，只允许被一个标签包裹</li>
<li>标签一定要闭合</li>
<li>注释被{}包起来</li>
</ul>
<h4 id="React组件"><a href="#React组件" class="headerlink" title="React组件"></a>React组件</h4><ul>
<li>无状态组件创建时始终保持了==一个实例==</li>
<li>有状态组件创建几次组件就会创建几次实例</li>
</ul>
<h4 id="React数据流"><a href="#React数据流" class="headerlink" title="React数据流"></a>React数据流</h4><h5 id="state"><a href="#state" class="headerlink" title="state"></a>state</h5><ul>
<li>setState是==异步==方法<h5 id="props"><a href="#props" class="headerlink" title="props"></a>props</h5></li>
<li>props本身是不可变的（==readonly==）</li>
<li><p>==defaultProps==静态变量可以定义props默认配置（==默认类型==）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">static defaultProps = &#123;</span><br><span class="line">    classPrefix: &apos;tabs&apos;, </span><br><span class="line">    onChange: () =&gt; &#123;&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>React中有一个内置的prop：children，代表组件的子组件集合</p>
</li>
<li>JavaScript不是强类型的语言，React对此做了改进，==propTypes==用于规范props的类型与必要状态（==类型检查==）。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">static propTypes = &#123;</span><br><span class="line">  tab: React.PropTypes.oneOfType([</span><br><span class="line">    React.PropTypes.string,</span><br><span class="line">    React.PropTypes.node,</span><br><span class="line">  ]).isRequired,</span><br><span class="line">  order: React.PropTypes.string.isRequired,</span><br><span class="line">  disble: React.PropTypes.bool,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="React生命周期"><a href="#React生命周期" class="headerlink" title="React生命周期"></a>React生命周期</h4><p>分为挂载、渲染、卸载几个阶段</p>
<h5 id="挂载或卸载"><a href="#挂载或卸载" class="headerlink" title="挂载或卸载"></a>挂载或卸载</h5><p>主要做组件状态初始化</p>
<h6 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">componentWillMount--&gt;render</span><br><span class="line">render--&gt;componentDidMount</span><br></pre></td></tr></table></figure>
<h6 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">render--&gt;componentWillUnmount</span><br></pre></td></tr></table></figure>
<h5 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h5><p>指父组件向下传递props或组件自身执行setState方法时发生的一系列更新动作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component, PropTypes&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        //this.setState(&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h6 id="组件自身state更新"><a href="#组件自身state更新" class="headerlink" title="组件自身state更新"></a>组件自身state更新</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">shouldComponentUpdate--&gt;componentWillUpdate</span><br><span class="line">componentWillUpdate--&gt;render</span><br><span class="line">render--&gt;componentDidUpdate</span><br></pre></td></tr></table></figure>
<p>==不能在componentWillUpdate里执行setState==。</p>
<h6 id="父组件更新props而更新"><a href="#父组件更新props而更新" class="headerlink" title="父组件更新props而更新"></a>父组件更新props而更新</h6><ul>
<li>在shouldComponentUpdate之前先执行componentWillReceiveProps。</li>
<li>该方法可作为React在==props传入后，渲染之前==setState。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="React与DOM"><a href="#React与DOM" class="headerlink" title="React与DOM"></a>React与DOM</h4><h5 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h5><p>refs是React组件中特殊的props，可以附加到任何一个组件上。组件被调用时会新建一个该组件的实例，refs则指向这个实例。</p>
<ul>
<li>refs放在原生DOM组件中可以得到其DOM节点</li>
<li>refs放在React组件中则获得组件的实例，可以调用该组件的实例方法</li>
</ul>
<h2 id="漫谈React"><a href="#漫谈React" class="headerlink" title="漫谈React"></a>漫谈React</h2><h3 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h3><p>在React底层，主要对合成事件做了两件事：事件委派和自动绑定。</p>
<h5 id="在React中使用原生事件"><a href="#在React中使用原生事件" class="headerlink" title="在React中使用原生事件"></a>在React中使用原生事件</h5><p>React生命周期方法中，componentDidMount会在组件已经完成安装并且在浏览器中存在真实的DOM后调用，此时可以完成原生事件的绑定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class NativeEventDemo extends Component &#123;</span><br><span class="line">    componentDidMound() &#123;</span><br><span class="line">        this.refs.button.addEventListener(&apos;click&apos;, e =&gt; &#123;</span><br><span class="line">            handleClick(e);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    handerClick(e) &#123;</span><br><span class="line">        console.log(e);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentWillUnMount() &#123;</span><br><span class="line">        this.refs.button.removeEventListener(&apos;click&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;button ref=&quot;button&quot;&gt;Test&lt;/button&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>==<strong>注：在React中使用DOM原生事件时，一定要在组件卸载时手动卸除，否则很可能会出现内存泄漏的问题。</strong>==</p>
<h5 id="对比React合成事件与JavaScript原生事件"><a href="#对比React合成事件与JavaScript原生事件" class="headerlink" title="对比React合成事件与JavaScript原生事件"></a>对比React合成事件与JavaScript原生事件</h5><ul>
<li>浏览器原生DOM事件的传播可以分为三个阶段：事件捕获阶段、事件处理以及事件冒泡。React的合成事件并没有实现事件捕获，仅仅支持了事件冒泡机制。阻止事件传播e.preventDefault();</li>
<li>React合成事件的时间类型是JavaScript原生事件类型的一个子集。</li>
</ul>
<h3 id="组件间通信"><a href="#组件间通信" class="headerlink" title="组件间通信"></a>组件间通信</h3><h5 id="父组件向子组件通信"><a href="#父组件向子组件通信" class="headerlink" title="父组件向子组件通信"></a>父组件向子组件通信</h5><p>父组件通过props向子组件传递需要的信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;Component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">function ListItem(&#123;value&#125;) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;li&gt;</span><br><span class="line">            &lt;span&gt;&#123;value&#125;&lt;/span&gt;</span><br><span class="line">        &lt;/li&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function List(&#123;list, title&#125;) &#123;</span><br><span class="line">    return(</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            &lt;ListTitle title=&#123;title&#125; /&gt;</span><br><span class="line">            &lt;ul&gt;</span><br><span class="line">                &#123;this.props.list.map((entry, index) =&gt; &#123;</span><br><span class="line">                    &lt;ListItem key=&#123;`list-$&#123;index&#125;`&#125; value=&#123;entry.text&#125;&gt;</span><br><span class="line">                    </span><br><span class="line">                &#125;)&#125;</span><br><span class="line">            &lt;/ul&gt;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="子组件向父组件通信"><a href="#子组件向父组件通信" class="headerlink" title="子组件向父组件通信"></a>子组件向父组件通信</h5><ul>
<li>利用回调函数</li>
<li>利用自定义事件机制</li>
</ul>
<p>this.props.function()</p>
<h5 id="跨级组件通信"><a href="#跨级组件通信" class="headerlink" title="跨级组件通信"></a>跨级组件通信</h5><h3 id="组件新能优化"><a href="#组件新能优化" class="headerlink" title="组件新能优化"></a>组件新能优化</h3><p>影响网页性能最大的因素是浏览器的==重绘==和==重排版==。</p>
<h5 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h5><p>纯函数由三大原则构成：</p>
<ul>
<li>给定相同的输入，返回相同的输出</li>
<li>过程没有副作用（在纯函数中不能改变外部状态）</li>
<li>没有额外的状态依赖（方法内的状态都只在方法的生命周期内存活，即不能再方法内使用共享变量）</li>
</ul>
<h5 id="PureRender"><a href="#PureRender" class="headerlink" title="PureRender"></a>PureRender</h5><p>Pure指的是组件满足纯函数的条件，即组件的渲染是被相同的props和state渲染进而得到相同的结果</p>
<h5 id="Immutable"><a href="#Immutable" class="headerlink" title="Immutable"></a>Immutable</h5><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><ul>
<li>如果每一个子组件是一个数组或迭代器，必须有一个唯一的key prop</li>
<li>key用来做Virtual DOM dif</li>
<li>当key相同时，只渲染第一个相同key的项，且会报一个警告</li>
</ul>
<h2 id="解读React源码"><a href="#解读React源码" class="headerlink" title="解读React源码"></a>解读React源码</h2><p>Virtual DOM实际上是在浏览器端用JavaScript实现的一套DOM API，它之于React就好似一个虚拟空间，包括一套Virtual DOM模型、生命周期的维护和管理、性能高效的diff算法和将Virtual DOM展示为原生DOM的path方法。</p>
<h4 id="Virtual-DOM模型"><a href="#Virtual-DOM模型" class="headerlink" title="Virtual DOM模型"></a>Virtual DOM模型</h4><p>一个DOM标签所需的基本元素：</p>
<ul>
<li>标签名</li>
<li>节点属性，包含样式、属性、事件等</li>
<li>子节点</li>
<li>标识id</li>
<li>Virtual DOM中的节点称为ReactNode，它分为三种类型ReactElement、ReactFragment和ReactText。其中，ReactElement又分为ReactComponentElement和ReactDOMElement。</li>
</ul>
<h5 id="创建React元素"><a href="#创建React元素" class="headerlink" title="创建React元素"></a>创建React元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//createElement只是做了简单的参数修正，返回一个ReactElement实例对象，也就是虚拟元素的实例</span><br><span class="line">ReactElement.createElement = function(type, config, children)&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="DOM标签组件"><a href="#DOM标签组件" class="headerlink" title="DOM标签组件"></a>DOM标签组件</h5><p>ReactDOMComponent针对Virtual DOM标签的处理主要分为：</p>
<ul>
<li>属性的更新，包括更新样式、更新属性、处理事件等。</li>
<li>子节点的更新，包括更新内容、更新子节点，涉及diff算法。</li>
</ul>
<h6 id="更新属性"><a href="#更新属性" class="headerlink" title="更新属性"></a>更新属性</h6><ul>
<li>如果存在事件，则针对当前的节点添加事件代理</li>
<li>如果存在样式，首先会对样式进行合并操作，然后创建样式</li>
<li>创建属性</li>
<li>创建唯一标识</li>
</ul>
<p>删除不需要的旧属性，更新新属性。</p>
<h6 id="更新子节点"><a href="#更新子节点" class="headerlink" title="更新子节点"></a>更新子节点</h6><ul>
<li>删除不需要的子节点和内容</li>
<li>更新子节点和内容</li>
</ul>
<h4 id="生命周期的管理艺术"><a href="#生命周期的管理艺术" class="headerlink" title="生命周期的管理艺术"></a>生命周期的管理艺术</h4><p>生命周期在不同状态下的执行顺序：</p>
<ul>
<li>当首次挂载时，按顺序执行==getDefaultProps==、==getInitialState==、componentWillMount、render、componentDidMount</li>
<li>当卸载组件时，执行componentWillUnmount</li>
<li>当重新挂载组件时，按顺序执行==getInitialState==、componentWillMount、render和componentDidMount，但并不执行getDefaultProps</li>
<li>当再次渲染组件时，组件接受到更新的状态，此时按顺序执行componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate。</li>
</ul>
<h6 id="first-render"><a href="#first-render" class="headerlink" title="first render"></a>first render</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">getDefaultProps--&gt;getInitialState</span><br><span class="line">getInitialState--&gt;componentWillMount</span><br><span class="line">componentWillMount--&gt;render</span><br><span class="line">render--&gt;componentDidMount</span><br></pre></td></tr></table></figure>
<h6 id="props-change"><a href="#props-change" class="headerlink" title="props change"></a>props change</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">componentWillReceiveProps--&gt;shouldComponentUpdate</span><br><span class="line">shouldComponentUpdate--&gt;componentWillUpdate</span><br><span class="line">componentWillUpdate--&gt;render</span><br><span class="line">render--&gt;componentDidUpdate</span><br></pre></td></tr></table></figure>
<h6 id="state-change"><a href="#state-change" class="headerlink" title="state change"></a>state change</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">shouldComponentUpdate--&gt;componentWillUpdate</span><br><span class="line">componentWillUpdate--&gt;render</span><br><span class="line">render--&gt;componentDidUpdate</span><br></pre></td></tr></table></figure>
<p>自定义组件的声明周期主要通过3个阶段进行管理：MOUNTING、RECEIVE_PROPS、UNMOUNTING</p>
<h6 id="MOUNTING"><a href="#MOUNTING" class="headerlink" title="MOUNTING"></a>MOUNTING</h6><p>mountComponent负责管理生命周期中的getInitialState、componentWillMount、render和componentDidMount。</p>
<ul>
<li>==getDefault是通过构造函数进行管理==的，所以也是整个生命周期中最先开始执行的，==只执行一次==。</li>
<li>此时在componentWillMount中调用setState方法不会触发re-render，而是会进行==state合并==</li>
<li>mountComponent的本质是通过==递归==渲染内容，由于递归的特性，父组件的componentWillMount在其子组件的componentWillMount之前调用，父组件的componentDidMount在子组件的componentDidMount之后调用】</li>
</ul>
<h6 id="RECEIVE-PROPS"><a href="#RECEIVE-PROPS" class="headerlink" title="RECEIVE_PROPS"></a>RECEIVE_PROPS</h6><p>updateComponent负责管理生命周期中的componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render和componentDidUpdate。</p>
<ul>
<li>首先通过updateComponent更新组件，如果前后元素不一致，说明需要进行组件更新</li>
<li>此时在componentWillReceiveProps中调用setState不会触发re-render，而是会进行==state合并==</li>
<li>只有在render和componentDidUpdate中才能获取到更新后的this.state</li>
<li>updateComponent本质上也是通过递归渲染内容，父组件的componentWillUpdate是在其子组件的componentWillUpdate之前调用，父组件的componentDidUpdate子组件的componentDidUpdate之后调用</li>
</ul>
<h6 id="UNMOUNTING"><a href="#UNMOUNTING" class="headerlink" title="UNMOUNTING"></a>UNMOUNTING</h6><p>unmountComponent负责管理生命周期中的componentWilUnmount。</p>
<ul>
<li>如果存在componentWillUnmount，则执行并重置所有相关参数、更新队列以及更新状态</li>
<li>此时在componentWillUnmount中调用setState不会触发re-render，因为==所有更新队列和更新状态都被重置为null，并清除了公共类，完成了组件卸载操作==。</li>
</ul>
<h4 id="解密setState机制"><a href="#解密setState机制" class="headerlink" title="解密setState机制"></a>解密setState机制</h4><ul>
<li>setState通过一个队列机制实现state更新</li>
<li>当执行setState时，会将需要更新的state合并后放入状态机，而不会立刻更新this.state</li>
<li>如果在shouldComponentUpdate或componentWillUpdate方法中调用setState，会造成循环调用，使得浏览器内存占满后崩溃</li>
</ul>
<h6 id="setState调用栈"><a href="#setState调用栈" class="headerlink" title="setState调用栈"></a>setState调用栈</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123;component&#125; from &apos;react&apos;;</span><br><span class="line"></span><br><span class="line">class Example extends Component &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line">        super();</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            val: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">        console.log(this.state.val);</span><br><span class="line">        </span><br><span class="line">        this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">        console.log(this.state.val);</span><br><span class="line">        </span><br><span class="line">        setTimeout(() =&gt; &#123;</span><br><span class="line">            this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">            console.log(this.state.val);</span><br><span class="line">            </span><br><span class="line">            this.setState(&#123;val: this.state.val + 1&#125;);</span><br><span class="line">            console.log(this.state.val);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//输出 0 0 2 3</span><br></pre></td></tr></table></figure>
<h6 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h6><ul>
<li>事务就是将需要执行的方法使用wrapper封装起来，再通过事务提供的perform方法执行</li>
</ul>
<h4 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h4><p>diff帮助计算出Virtual DOM中真正变化的部分，并只针对该部分进行原生DOM操作，而非重新渲染整个页面</p>
<h5 id="详解diff"><a href="#详解diff" class="headerlink" title="详解diff"></a>详解diff</h5><h6 id="diff策略"><a href="#diff策略" class="headerlink" title="diff策略"></a>diff策略</h6><ul>
<li>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计</li>
<li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构</li>
<li>对于同一层级的一组子节点，可以通过唯一id进行区分</li>
</ul>
<p>React分别对tree diff、component diff以及element diff进行算法优化。</p>
<h6 id="tree-diff"><a href="#tree-diff" class="headerlink" title="tree diff"></a>tree diff</h6><ul>
<li>对树进行分层比较，两棵树只会对==同一层次==的节点进行比较</li>
<li>当发现节点已经不存在时，则改节点及其子节点会被完全删除掉</li>
</ul>
<h6 id="component-diff"><a href="#component-diff" class="headerlink" title="component diff"></a>component diff</h6><ul>
<li>如果是同一类型的组件，按照原策略继续比较Virtual DOM树即可</li>
<li>如果不是，则将改组件判断为dirty component，从而替换整个组件下的所有子节点</li>
<li>React允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析</li>
</ul>
<h6 id="element-diff"><a href="#element-diff" class="headerlink" title="element diff"></a>element diff</h6><ul>
<li>INSERT_MARKUP: 新的组件类型不在旧集合里，需对新节点执行插入操作</li>
<li>MOVE_EXISTING: 旧集合中有新组件类型，且element是可更新类型，需要做移动操作，可以复用以前的DOM节点</li>
<li>REMOVE_NODE: 旧组件类型，在新集合里也有，但对应的element不同则不能直接复用和更新，需要执行删除操作，或者旧组件不在新集合里的，也需要执行删除操作</li>
</ul>
<p>==节点在新集合中的索引值大于在旧集合中的索引时，需移动==<br>==删除操作是移动完成之后遍历旧集合，若有新集合中未出现的节点则删除==</p>
<h4 id="React-Patch方法"><a href="#React-Patch方法" class="headerlink" title="React Patch方法"></a>React Patch方法</h4><p>将tree diff计算出来的DOM差异队列更新到真实的DOM节点上，让浏览器能够渲染出更新的数据</p>
<ul>
<li>主要通过遍历差异队列实现</li>
</ul>
<h2 id="认识Flux架构模式"><a href="#认识Flux架构模式" class="headerlink" title="认识Flux架构模式"></a>认识Flux架构模式</h2><h4 id="React独立架构"><a href="#React独立架构" class="headerlink" title="React独立架构"></a>React独立架构</h4><ul>
<li>含有抽象数据而没有业务逻辑的组件为容器型组件</li>
<li>没有数据请求逻辑只有业务逻辑的组件为展示型组件</li>
</ul>
<h4 id="MV-与Flux"><a href="#MV-与Flux" class="headerlink" title="MV*与Flux"></a>MV*与Flux</h4><h6 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC/MVVM"></a>MVC/MVVM</h6><p>主要涉及三种角色：Model、View和Controller</p>
<ul>
<li>Model：负责保存应用数据，和后端交互同步应用数据，或校验数据</li>
<li>View：是Model的可视化表示，表示当前状态的视图。前端View负责构建和维护DOM元素。</li>
<li>Controller：负责连接View和Model，Model的任何改变会应用到View中，View的操作会通过Controller应用到Model中</li>
</ul>
<h6 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h6><p>核心思想是==数据和逻辑永远单向流动==。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[Action] --&gt; B[Dispatcher]</span><br><span class="line">B --&gt; C[store]</span><br><span class="line">C --&gt; D[View]</span><br><span class="line">D --&gt; E[Action]</span><br><span class="line">E --&gt; B</span><br></pre></td></tr></table></figure>
<p>在Flux应用中，数据从action到dispatcher再到store，最终到view的路线是单项不可逆的</p>
<h4 id="Flux基本概念"><a href="#Flux基本概念" class="headerlink" title="Flux基本概念"></a>Flux基本概念</h4><p>一个Flux应用由3大部分组成：dispatcher、store和view，其中dispatcher负责分发事件；store负责保存数据，同时响应时间并更新数据；view负责订阅store中的数据。</p>
<h6 id="dispatcher"><a href="#dispatcher" class="headerlink" title="dispatcher"></a>dispatcher</h6><p>dispatcher是Flux中最核心的方法，也是flux这个npm包中的核心方法。<br>只需关心.register(callback)和.dispatch(action)这两个API。</p>
<ul>
<li>register方法用来注册一个监听器</li>
<li>dispatch方法用来分发一个action</li>
</ul>
<h6 id="action"><a href="#action" class="headerlink" title="action"></a>action</h6><p>action是一个普通的JavaScript对象，一般包含type、payload等字段，用于描述一个事件以及需要改变的相关数据。</p>
<h6 id="store"><a href="#store" class="headerlink" title="store"></a>store</h6><ul>
<li>在Flux中，store负责保存数据，并定义修改数据的逻辑，同时调用dispatcher的register方法将自己注册为一个监听器。</li>
<li>每次使用dispatcher的dispatch方法分发一个action时，store注册的监听器会被调用，同时得到这个action作为参数。</li>
<li>在Flux中，store对外只暴露getter而不暴露setter，即只能读取store中的数据而不能进行任何修改。</li>
</ul>
<h6 id="controller-view"><a href="#controller-view" class="headerlink" title="controller-view"></a>controller-view</h6><p>一般来说，controller-view是整个应用最顶层的view，主要进行store与React组件之间的绑定，定义数据更新以及传递的方式</p>
<h6 id="view"><a href="#view" class="headerlink" title="view"></a>view</h6><p>如果界面操作需要修改数据，必须使用dispatcher分发一个action。</p>
<h6 id="actionCreator"><a href="#actionCreator" class="headerlink" title="actionCreator"></a>actionCreator</h6><h2 id="深入Redux应用架构"><a href="#深入Redux应用架构" class="headerlink" title="深入Redux应用架构"></a>深入Redux应用架构</h2><h4 id="Redux简介"><a href="#Redux简介" class="headerlink" title="Redux简介"></a>Redux简介</h4><h5 id="Redux三大原则"><a href="#Redux三大原则" class="headerlink" title="Redux三大原则"></a>Redux三大原则</h5><h6 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h6><ul>
<li>在Redux的思想里，一个应用永远只有唯一的数据源。</li>
<li>整个应用状态都保存在一个对象中</li>
</ul>
<h6 id="状态是只读的"><a href="#状态是只读的" class="headerlink" title="状态是只读的"></a>状态是只读的</h6><p>定义一个reducer，其功能是根据当前触发的action对当前应用的状态（state）进行迭代。没有直接修改应用的状态，而是==返回了一份全新的状态==。</p>
<ul>
<li>Reducer提供的createStore方法会根据reducer生成store</li>
<li>用store.dispatch方法来修改状态</li>
</ul>
<p>==###### ==状态修改均由纯函数完成<br>在Redux里，通过定义reducer来确定状态的修改，而每一个reducer都是纯函数，即其没有副作用，接受一定的输入，必定会得到一定的输出。</p>
<h5 id="Redux核心API"><a href="#Redux核心API" class="headerlink" title="Redux核心API"></a>Redux核心API</h5><p>Redux的核心是一个store，这个store由Redux提供的createStore（reducers[, initialState]）方法生成。</p>
<ul>
<li>在Redux里，负责响应action并修改数据的角色就是reducer</li>
<li>reducer在处理action的同时，还需接受一个previousState参数</li>
<li>reducer的职责是根据previousState和action计算出新的newState</li>
</ul>
<p>Redux中最核心的API是createStore，通过createStore方法创建的store是一个对象，包含四个方法：</p>
<ul>
<li>getState（）：获取store当前状态</li>
<li>dispatch（action）：分发一个action，并返回这个action，这是==唯一能改变store中数据的方式==</li>
<li>subscribe（listener）：注册一个监听者，在store发生变化时调用</li>
<li>replaceReducer（nextReducer）：更新当前store里的reducer，一般只在开发模式中调用该方法</li>
</ul>
<p>subscribe（）和replaceReducer（）方法一般会在Redux与某个系统做桥接的时候使用</p>
<h5 id="与React绑定"><a href="#与React绑定" class="headerlink" title="与React绑定"></a>与React绑定</h5><p>react-redux提供了一个组件和一个API帮助Redux和React进行绑定。</p>
<p>一个是React组件<provider>，一个是connect（）</provider></p>
<ul>
<li><provider>接受一个store作为props，它是整个Redux应用的顶层组件</provider></li>
<li>connect（）提供了在整个React应用的任意组件中获取store中数据的功能</li>
</ul>
<h4 id="Redux-middleware"><a href="#Redux-middleware" class="headerlink" title="Redux middleware"></a>Redux middleware</h4><h5 id="middleware的由来"><a href="#middleware的由来" class="headerlink" title="middleware的由来"></a>middleware的由来</h5><h6 id="Redux同步数据流动"><a href="#Redux同步数据流动" class="headerlink" title="Redux同步数据流动"></a>Redux同步数据流动</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">button -. callback .-&gt; dispatch</span><br><span class="line">dispatch == action ==&gt; reducer</span><br><span class="line">reducer -. state .-&gt; view</span><br></pre></td></tr></table></figure>
<h6 id="应用middleware后Redux处理事件的逻辑"><a href="#应用middleware后Redux处理事件的逻辑" class="headerlink" title="应用middleware后Redux处理事件的逻辑"></a>应用middleware后Redux处理事件的逻辑</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">button -. callback .-&gt; mid1</span><br><span class="line">mid1 --&gt; mid2</span><br><span class="line">mid2 == action ==&gt; ...</span><br><span class="line">... --&gt; dispatch</span><br><span class="line">dispatch == action ==&gt; reducer</span><br><span class="line">reducer -. state .-&gt; view</span><br></pre></td></tr></table></figure>
<p>每一个middleware处理一个相对独立的业务需求，通过串联不同的middleware实现变化多样的功能</p>
<h5 id="理解middleware机制"><a href="#理解middleware机制" class="headerlink" title="理解middleware机制"></a>理解middleware机制</h5><p>Redux提供了applyMiddleware方法来加载middleware。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import compose from &apos;./compose&apos;;</span><br><span class="line"></span><br><span class="line">export default function applyMiddleware(...middlewares) &#123;</span><br><span class="line">    return (next) =&gt; (reducer, initialState) &#123;</span><br><span class="line">        let store = next(reducer, initialState);</span><br><span class="line">        let dispatch = sotre.dispatch;</span><br><span class="line">        let chain = [];</span><br><span class="line">        </span><br><span class="line">        var middlewareAPI = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: (action) =&gt; dispatch(action),</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        chain = middlewares.map(middleware =&gt; middleware(middlewareAPI));</span><br><span class="line">        dispatch = compose(...chain)(store.dispatch);</span><br><span class="line">        </span><br><span class="line">        return &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="函数式编程思想设计"><a href="#函数式编程思想设计" class="headerlink" title="函数式编程思想设计"></a>函数式编程思想设计</h6><p>middleware是一个层层包裹的匿名函数，即函数式编程中的currying，是一种使用匿名单参数函数来实现多参数的方法。</p>
<p>currying的middleware皆有的好处：</p>
<ul>
<li>易串联：currying函数具有延迟执行的特性，通过不断currying形成的middleware可以累积参数，再配合组合（compose）的方式，很容易形成pipeline来处理数据流</li>
<li>共享store：在applyMiddleware执行的过程中，store还是旧的，但是因为闭包的存在，applyMiddleware完成后，所有的middleware内部拿到的store是最新且相同的。</li>
</ul>
<h6 id="给middleware分发store"><a href="#给middleware分发store" class="headerlink" title="给middleware分发store"></a>给middleware分发store</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建普通的store</span><br><span class="line">let newStore = applyMiddleware(mid1, mid2, mid3, ...)(createStore)(reducer, null);</span><br></pre></td></tr></table></figure>
<h6 id="组合串联middleware"><a href="#组合串联middleware" class="headerlink" title="组合串联middleware"></a>组合串联middleware</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dispatch = compose(...chain)(store.dispatch);</span><br><span class="line"></span><br><span class="line">//假设n=3，dispatch为</span><br><span class="line">dispatch = f1(f2(f3(store.dispatch)));</span><br></pre></td></tr></table></figure>
<h6 id="不能在middleware中调用dispatch"><a href="#不能在middleware中调用dispatch" class="headerlink" title="不能在middleware中调用dispatch"></a>不能在middleware中调用dispatch</h6><h4 id="Redux异步流"><a href="#Redux异步流" class="headerlink" title="Redux异步流"></a>Redux异步流</h4><h4 id="Redux与路由"><a href="#Redux与路由" class="headerlink" title="Redux与路由"></a>Redux与路由</h4><p>在Redux应用中，遇到了一些新的问题，其中最迫切的是，应用程序的所有状态都应该保存在一个单一的store中，而当前的路由状态很明显也属于应用状态的一部分。如果直接使用React Router，就意味着所有路由相关的信息脱离了Redux store的控制，这样就违背了Redux的设计思想。</p>
<h5 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h5><h6 id="路由的基本原理"><a href="#路由的基本原理" class="headerlink" title="路由的基本原理"></a>路由的基本原理</h6><p>理由的基本原理即是保证View和URL同步，而View可以看成是资源的一种表现。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">A((Action)) == 获取资源 ==&gt; B((Action))</span><br><span class="line"></span><br><span class="line">B == render ==&gt; C((Action))</span><br><span class="line">C == 用户与界面交互 ==&gt; A</span><br></pre></td></tr></table></figure>
<h6 id="React-Router特性"><a href="#React-Router特性" class="headerlink" title="React Router特性"></a>React Router特性</h6><ul>
<li>在React中，组件就是一个方法，props作为方法的参数，当它们发生变化时触发方法执行，重绘View</li>
<li>在React Router中，可以把Router组件看成一个方法，location作为参数，返回的结果同样是View</li>
</ul>
<h6 id="声明式路由"><a href="#声明式路由" class="headerlink" title="声明式路由"></a>声明式路由</h6><ul>
<li>React是声明式编程，所有的交互逻辑都在render返回的JSX标签中得到体现</li>
<li>React Router允许使用JSX表现来书写声明式的路由</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Router, Route, browserHistory&#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">const routes = (</span><br><span class="line">    &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">        &lt;Route path=&quot;/&quot; component=&#123;App&#125; /&gt;</span><br><span class="line">    &lt;/Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h6 id="嵌套路由及路径匹配"><a href="#嵌套路由及路径匹配" class="headerlink" title="嵌套路由及路径匹配"></a>嵌套路由及路径匹配</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123;Router, Route, IndexRoute, browserHistory&#125; from &apos;react-router&apos;;</span><br><span class="line"></span><br><span class="line">const routes = (</span><br><span class="line">    &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">        &lt;IndexRoute component=&#123;MailList&#125; /&gt;</span><br><span class="line">        &lt;Route path=&quot;/mail/:mailId&quot; component=&#123;Mail&#125;&gt;&lt;/Route&gt;</span><br><span class="line">    &lt;/Route&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>在声明路由时，==path==属性指明了当前路由匹配的路径形式</li>
<li>若某条路由需要参数，只用==加上 :参数名== 即可</li>
</ul>
<h6 id="支持多种路由切换方式"><a href="#支持多种路由切换方式" class="headerlink" title="支持多种路由切换方式"></a>支持多种路由切换方式</h6><p>路由切换可以使用hashChange或history.pushState。</p>
<ul>
<li>hashChange拥有良好的浏览器兼容性，但是url中多了/#/部分</li>
<li>history.pushState能提供优雅的url，但需要额外的服务端配置解决任意路径刷新的问题</li>
</ul>
<p>React Router提供了两种解决方案</p>
<p>==browserHistory即history.pushState的实现==</p>
<h4 id="React-Router-Redux"><a href="#React-Router-Redux" class="headerlink" title="React Router Redux"></a>React Router Redux</h4><p>职责主要是将应用的路由信息与Redux的store绑定在一起</p>
<p>采用Redux架构时，所有的应用状态都必须放在一个单一的store中管理，路由状态也不例外</p>
<h6 id="将React-Router与Redux-store绑定"><a href="#将React-Router与Redux-store绑定" class="headerlink" title="将React Router与Redux store绑定"></a>将React Router与Redux store绑定</h6><p>React Router Redux提供了简单直白的API syncHistoryWithStore来完成与Redux store的绑定工作。只需传入React Router中的history，以及Redux中的store，就可以获得一个增强后的history对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from  &apos;react-router&apos;;</span><br><span class="line">import &#123; syncHistoryWithState &#125; from &apos;react-router-redux&apos;;</span><br><span class="line">import reducers from &apos;&lt;project-path&gt;/reducers&apos;</span><br><span class="line"></span><br><span class="line">const store = createStore(reducers);</span><br><span class="line">const history = syncHistoryWithStore(browserHistory, store);</span><br></pre></td></tr></table></figure>
<h6 id="用Redux的方式改变路由"><a href="#用Redux的方式改变路由" class="headerlink" title="用Redux的方式改变路由"></a>用Redux的方式改变路由</h6><p>无论是Flux还是Redux，想要改变数据，必须要分发一个action</p>
<ul>
<li>在此之前，需要对Redux的store进行一些增强，以便分发的action能被正确识别</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import &#123; browserHistory &#125; from &apos;react-router&apos;;</span><br><span class="line">import &#123; routerMiddleware&#125; from &apos;react-router-redux&apos;;</span><br><span class="line"></span><br><span class="line">const middleware = routerMiddleware(browserHistory);</span><br><span class="line">const store = createStore(</span><br><span class="line">    reducers,</span><br><span class="line">    applyMiddleware(middleware)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<ul>
<li>用store.dispatch来分发一个路由变动的action<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123;push&#125; from &apos;react-router-redux&apos;;</span><br><span class="line"></span><br><span class="line">store.dispatch(push(&apos;/home&apos;));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Redux与组件"><a href="#Redux与组件" class="headerlink" title="Redux与组件"></a>Redux与组件</h4><h5 id="容器型组件"><a href="#容器型组件" class="headerlink" title="容器型组件"></a>容器型组件</h5><p>容器型组件，意为组件是怎么工作的，具体一些就是数据是怎么更新的。不包含任何Virtual DOM的修改或组合，也不会包含组件的样式。</p>
<ul>
<li>如果映射到Flux上，容器型组件就是与store绑定的组件</li>
<li>如果映射到Redux上，容器型组件就是使用connect的组件</li>
</ul>
<h5 id="展示型组件"><a href="#展示型组件" class="headerlink" title="展示型组件"></a>展示型组件</h5><p>展示型组件，意为组件是怎么渲染的。包含Virtual DOM的修改和组合，也可能包含组件的样式。</p>
<h5 id="Redux中的组件"><a href="#Redux中的组件" class="headerlink" title="Redux中的组件"></a>Redux中的组件</h5><h6 id="Layouts"><a href="#Layouts" class="headerlink" title="Layouts"></a>Layouts</h6><ul>
<li>指的是页面布局组件，描述了页面的基本结构，目的是将主框架与页面主题内容分离</li>
<li>常常是无状态函数，传入主题内容的children属性</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//一般写法为</span><br><span class="line">const layout = (&#123; children &#125;) =&gt; (</span><br><span class="line">    &lt;div className=&apos;container&apos;&gt;</span><br><span class="line">        &lt;Header /&gt;</span><br><span class="line">        &lt;div className=&apos;content&apos;&gt;</span><br><span class="line">            &#123; children &#125;</span><br><span class="line">        &lt;/div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h6 id="views"><a href="#views" class="headerlink" title="views"></a>views</h6><ul>
<li>指的是子路由入口组件，描述子路由入口的基本结构，包含由此路由下所有的展示型组件</li>
<li>为了保持子组件的纯净，在这一层组件中定义了数据和action的入口，从这里开始将它们分发到子组件中去</li>
</ul>
<h6 id="Components"><a href="#Components" class="headerlink" title="Components"></a>Components</h6><ul>
<li>末级渲染组件，描述了从路由以下的子组件</li>
<li>包含具体的业务逻辑和交互</li>
<li>所有的数据和action都是由Views传下来的，即其是可以完全脱离数据层而存在的展示型组件</li>
</ul>
<h2 id="Redux高阶运用"><a href="#Redux高阶运用" class="headerlink" title="Redux高阶运用"></a>Redux高阶运用</h2><h4 id="高阶Reducer"><a href="#高阶Reducer" class="headerlink" title="高阶Reducer"></a>高阶Reducer</h4><p>在Redux架构中，reducer是一个纯函数，其职责是根据previousState和action计算出新的state</p>
<p>高阶reducer是指将reducer作为一个参数或者返回值的函数</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/11/flex 布局/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/11/flex 布局/" itemprop="url">flex布局</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-11T15:44:09+08:00">
                2018-07-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>flex是Flexible Box的缩写，意为“弹性布局”，是css3中作用于动态元素或者不知名大小元素的新布局，主要用于元素对齐、方向和容器的组织方式。flex容器最主要的特点是其能以最好的方式修改不同大小子元素的width和height，使其填满可用空间。</p>
<h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><p>flex布局由flex容器的父元素和其直接子元素flex items 组成。<br><img src="https://cdn.scotch.io/scotchy-uploads/2015/04/CSS3-Flexbox-Model.jpg" alt="image"></p>
<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>在父HTML元素上设置属性display就可以使用flex布局。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    display: -webkit-flex;      //Safari</span><br><span class="line">    display: flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若想表现得像行内元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    display: -webkit-inline-flex;       //Safari</span><br><span class="line">    display: inline-flex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>父元素上只需设置这一个属性，其全部直接子元素会自动转变为flex items。</strong></p>
<p>有许多方式能组织flexbox属性，但总的来说，最简便的还是将元素分为两个部分：flex容器和flexZ子元素。以下会介绍它们，并且说明其如何影响布局表现。</p>
<h4 id="flexbox容器属性"><a href="#flexbox容器属性" class="headerlink" title="flexbox容器属性"></a>flexbox容器属性</h4><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>该属性通过设置flex容器的主轴方向来指定flex元素在容器中排列的方向。</p>
<table>
<thead>
<tr>
<th>flex-direction</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>row（默认值）</td>
<td>主轴为水平方向，起点在左端</td>
</tr>
<tr>
<td>row-reverse</td>
<td>主轴为水平方向，起点在右端</td>
</tr>
<tr>
<td>column</td>
<td>主轴为垂直方向，起点在上沿</td>
</tr>
<tr>
<td>column-reverse</td>
<td>主轴为垂直方向，起点在下沿</td>
</tr>
</tbody>
</table>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-direction: row;        //Safari</span><br><span class="line">    flex-direction: row;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>row 方向为从左到右排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-direction-row.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-direction: row-reverse;        //Safari</span><br><span class="line">    flex-direction: row-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>row-reverse方向，flex元素从右到左行排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-direction-row-reverse.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-direction: column;         //Safari</span><br><span class="line">    flex-direction: column;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>column flex元素从上到下列排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-direction-column.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-direction: column-reverse;         //Safari</span><br><span class="line">    flex-direction: column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择column-reverse，flex元素从下到上列排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-direction-column-reverse.jpg" alt="image"></p>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>原始flexbox观念是容器在一条线上设置其子元素。flex-wrap属性用于控制flex容器中的子元素是在一条还是多条线上排列，并且控制多出来的行堆叠的方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-wrap: nowrap;          //Safari</span><br><span class="line">    flex-wrap: nowrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flex元素一行排列，默认情况下会有一定缩放来适应元素的宽度<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-wrap-nowrap.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-wrap: wrap;            //Safari</span><br><span class="line">    flex-wrap: wrap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素在多行上按从上从左到右，从上到下的方式排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-wrap-wrap.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-wrap: wap-reverse;     //Safari</span><br><span class="line">    flex-wrap: wap-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素在多行上按从左到右，从下到上的方式排列<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-wrap-wrap-reverse.jpg" alt="image"></p>
<p><strong>默认值：==nowrap==</strong></p>
<h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>该属性是flex-direction 和 flex-wrap 属性的简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-flex-flow: ||;      //Safari</span><br><span class="line">    flex-flow: ||;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>默认值：==row nowrap==</strong></p>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>justify-content属性在flex容器当前行主轴线上对齐flex元素。它能分配多余可用空间，不管flex元素在一条线上表现为不可改变，或者可变但是已是最大尺寸。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-justify-content: flex-start;    //Safari</span><br><span class="line">    justify-content: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素左对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-justify-content-flex-start.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-justify-content: flex-end;      //Safari</span><br><span class="line">    justify-content: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素右对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-justify-content-flex-end.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-justify-content: center;    //Safari</span><br><span class="line">    justify-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素居中<br><img src="https://cask.scotch.io/2015/04/flexbox-justify-content-center.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-justify-content: space-between;     //Safari</span><br><span class="line">    justify-content: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素相邻元素之间有等距间隔，首位元素与容器边缘对齐</p>
<p><img src="https://cask.scotch.io/2015/04/flexbox-justify-content-space-between.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-justify-content: space-around;      //Safari</span><br><span class="line">    justify-content: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素每个元素周围有一定间距，首位元素亦如此<br><img src="https://cask.scotch.io/2015/04/flexbox-justify-content-space-around.jpg" alt="images"></p>
<p><strong>默认值：==flex-start==</strong></p>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>flex元素沿当前容器交叉轴对齐，与justify-content相同，所不同的是方向。该属性设置所有元素的默认对齐方式，即使是未布局的元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-items: stretch;       //Safari</span><br><span class="line">    align-items: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素从交叉轴起点到终点填满整个高度<br><img src="https://cask.scotch.io/2015/04/flexbox-align-items-stretch.jpg" alt="images"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-items: flex-start;    //Safari</span><br><span class="line">    align-items: flex-start;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素按交叉轴起点对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-items-flex-start.jpg" alt="images"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-items: flex-end;      //Safari</span><br><span class="line">    align-items: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素按交叉轴终点对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-items-flex-end.jpg" alt="images"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-items: center;    //Safari</span><br><span class="line">    align-items: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素按交叉轴中点对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-items-center.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container&#123;</span><br><span class="line">    -webkit-align-items: baseline;      //Safari</span><br><span class="line">    align-items: baseline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素按每一行基线对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-items-baseline.jpg" alt="image"></p>
<p><strong>默认值：==stretch==</strong></p>
<h4 id="align-center"><a href="#align-center" class="headerlink" title="align-center"></a>align-center</h4><p>该属性轴线有多余空间时，定义flex容器每一行的对齐方式，当只有一行元素时，与justify-content属性对齐方式相同。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: stretch;     //Safari</span><br><span class="line">    align-content: stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素每行分配相等间距<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-stretch.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: flex-start;      //Safari</span><br><span class="line">    align-content: flex-start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素沿交叉轴起点对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-flex-start.jpg" alt="images"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: flex-end;    //Safari</span><br><span class="line">    align-content: flex-end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素沿交叉轴终点对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-flex-end.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: center;      //Safari</span><br><span class="line">    align-content: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素每行在容器内居中对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-center.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: space-between;       //Safari</span><br><span class="line">    align-content: space-between;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素每行有等距间隔，首位行与flex容器边缘对齐<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-space-between.jpg" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-container &#123;</span><br><span class="line">    -webkit-align-content: space-around;    //Safari</span><br><span class="line">    align-content: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>flex元素每行周围有相等空间<br><img src="https://cask.scotch.io/2015/04/flexbox-align-content-space-around.jpg" alt="images"></p>
<p><strong>默认值：==stretch==</strong></p>
<p><strong>注意事项：该属性只有在flex容器包含多行元素时才会生效，若为当行元素，该属性无效。</strong></p>
<h4 id="flex容器注意事项"><a href="#flex容器注意事项" class="headerlink" title="flex容器注意事项"></a>flex容器注意事项</h4><ul>
<li>所有colunm-*属性对flex container 均无效。</li>
<li>::first-line与::first-letter伪元素对flex容器无效</li>
</ul>
<h4 id="flexbox元素属性"><a href="#flexbox元素属性" class="headerlink" title="flexbox元素属性"></a>flexbox元素属性</h4><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>该属性控制flex容器中子元素排列顺序，数值越小，排列越靠前，默认值伪0。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-item &#123;</span><br><span class="line">    -webkit-order: ;    //Safari</span><br><span class="line">    order: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该属性能在不重构HTML代码的情况下重新排列flex元素。<br><img src="https://cask.scotch.io/2015/04/flexbox-order.jpg" alt="image"></p>
<p><strong>默认值：==0==</strong></p>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>当容器有剩余空间时，该属性定义flex元素相对于其它元素的放大比例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-ite &#123;</span><br><span class="line">    -webkit-flex-grow: ;    //Safari</span><br><span class="line">    flex-grow: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>若所有元素均有相同flex-grow值，则在容器中它们大小相同。<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-grow-1.jpg" alt="images"></p>
<p>第二个元素相对于其它元素而言占据更多空间<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-grow-2.jpg" alt="image"></p>
<p><strong>m默认值：==0==</strong></p>
<p><strong>注意事项：==负值无效==</strong></p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>若空间不足，该属性定义元素相较于其它元素而言缩小比例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-item &#123;</span><br><span class="line">    -webkit-flex-shrink: ;      //Safari</span><br><span class="line">    flex-shrink: ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般情况下，所有元素都可以被缩小，但若值设为0则保留原始大小<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-shrink.jpg" alt="images"></p>
<p><strong>默认值：==1==</strong></p>
<p><strong>注意：==负值无效==</strong></p>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>该属性与width和heigh属性取值相同，在分配多余空间之前定义flex元素的初始大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-item &#123;</span><br><span class="line">    -webkit-flex-basis: auto;       //Safari</span><br><span class="line">    flex-basis: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>flex-basis确定了第四个元素的初始大小<br><img src="https://cask.scotch.io/2015/04/flexbox-flex-basis.jpg" alt="images"></p>
<p><strong>m默认值：==auto==</strong></p>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>该属性是flex-grow, flex-shrink和flex-basis的简写。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-item &#123;</span><br><span class="line">    -webkit-flex: ;     //Safari</span><br><span class="line">    flex:  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>默认值：==0 1 auto==</strong></p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>align-self属性允许单个元素与其它元素有不一样的对齐方式，可覆盖align-items属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.flex-item &#123;</span><br><span class="line">    -webkit-align-self: auto | flex-start | flex-end | center | baseline | stretch;     //Safari</span><br><span class="line">    align-self: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第三、四个元素的align-self属性覆盖了其对齐方式<br><img src="https://cask.scotch.io/2015/04/flexbox-align-self.jpg" alt="images"></p>
<p><strong>默认值：==auto==</strong></p>
<p><strong>注意：默认值为auto，表示继承父元素align-items属性，如果没有父元素，则等同于stretch</strong></p>
<h4 id="flex元素注意事项"><a href="#flex元素注意事项" class="headerlink" title="flex元素注意事项"></a>flex元素注意事项</h4><ul>
<li>float，clear与vertical-align均对其无效，也不会使其脱离文档流。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/15/git学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/15/git学习笔记/" itemprop="url">git学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-15T11:27:36+08:00">
                2018-06-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="一级目录"><a href="#一级目录" class="headerlink" title="一级目录"></a>一级目录</h4><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>源代码</td>
</tr>
<tr>
<td>release</td>
<td>发布结果</td>
</tr>
<tr>
<td>test</td>
<td>单元测试用例</td>
</tr>
<tr>
<td>doc</td>
<td>文档</td>
</tr>
<tr>
<td>example</td>
<td>示例</td>
</tr>
</tbody>
</table>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h4 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h4><p><strong>Git有三种状态：</strong>==已提交（committed）、已修改（modified）和已暂存（staged）==。</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>committed</td>
<td>数据已经安全的保存在本地数据库中</td>
</tr>
<tr>
<td>modified</td>
<td>修改了文件，但还没保存到数据库中</td>
</tr>
<tr>
<td>staged</td>
<td>对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</td>
</tr>
</tbody>
</table>
<h4 id="Git项目的三个工作区域"><a href="#Git项目的三个工作区域" class="headerlink" title="Git项目的三个工作区域"></a>Git项目的三个工作区域</h4><p>==Git仓库、工作目录以及暂存区域==。</p>
<table>
<thead>
<tr>
<th>工作区域</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Git仓库目录</td>
<td>Git中最重要的部分。用来保存项目的元数据库</td>
</tr>
<tr>
<td>工作目录</td>
<td>对项目某个版本独立出来的内容</td>
</tr>
<tr>
<td>暂存区域</td>
<td>保存了下次将提交的文件列表信息，一般在Git仓库目录中</td>
</tr>
</tbody>
</table>
<p><img src="https://progit.bootcss.com/images/areas.png" alt="image"></p>
<p>基本的Git工作流程：</p>
<ol>
<li>在工作目录中修改文件。</li>
<li>暂存文件，将文件的快照放入暂存区域</li>
<li>提交更新，找到暂存区域的文件，将快照永久性存储到Git仓库目录</li>
</ol>
<h4 id="工作目录下Git文件两种状态"><a href="#工作目录下Git文件两种状态" class="headerlink" title="工作目录下Git文件两种状态"></a>工作目录下Git文件两种状态</h4><p>==已跟踪和未跟踪==。</p>
<p>已跟踪文件:</p>
<ul>
<li>被纳入了版本控制的文件</li>
<li>在上一次快照中有记录</li>
<li>状态可能处于未修改、已修改或已放入暂存区</li>
</ul>
<p>为跟踪文件：</p>
<ul>
<li>除已跟踪文件外的所有文件</li>
</ul>
<p>使用Git时文件的生命周期：<br><img src="https://progit.bootcss.com/images/lifecycle.png" alt="image"></p>
<h2 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h2><h4 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h4><p>有两种获取Git仓库的方法：</p>
<h5 id="在现有项目或目录下导入所有文件到Git中"><a href="#在现有项目或目录下导入所有文件到Git中" class="headerlink" title="在现有项目或目录下导入所有文件到Git中"></a>在现有项目或目录下导入所有文件到Git中</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure>
<p>该命令创建一个名为.git的子目录，包含初始化的Git仓库中所有的必须文件，这些文件是Git仓库的主干。</p>
<h6 id="git文件夹"><a href="#git文件夹" class="headerlink" title=".git文件夹"></a>.git文件夹</h6><p><img src="https://img-blog.csdn.net/20171128121600539?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWF5Zmxh/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="image"></p>
<table>
<thead>
<tr>
<th>文件（夹）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>hooks/</td>
<td>存放一些shell脚本</td>
</tr>
<tr>
<td>info/</td>
<td>存放仓库信息</td>
</tr>
<tr>
<td>logs/</td>
<td>保存所有更新的引用记录</td>
</tr>
<tr>
<td>logs/HEAD</td>
<td>内容：上一次提交哈希值 本次提交哈希值 <em> </em> Linux时间、东八区 提交信息</td>
</tr>
<tr>
<td>objects/</td>
<td>存放所有的git对象</td>
</tr>
<tr>
<td>refs/heads/</td>
<td>保存当前最新的一次提交的哈希值</td>
</tr>
<tr>
<td>COMMIT_CDITMSG</td>
<td>保存当前最新的一次提交的哈希值</td>
</tr>
<tr>
<td>config</td>
<td>git仓库的配置文件</td>
</tr>
<tr>
<td>description</td>
<td>仓库的描述信息，主要给gitweb等git托管系统使用</td>
</tr>
<tr>
<td>FETCH_HEAD</td>
<td>一个版本链接，指向着目前已经从远程仓库取下来的分支的末端</td>
</tr>
<tr>
<td>HEAD</td>
<td>映射到ref引用，能够找到下一次commit的前一次哈希值（logs内）</td>
</tr>
<tr>
<td>index</td>
<td>暂存区（stage），二进制文件</td>
</tr>
<tr>
<td>ORIG_HEAD</td>
<td>HEAD指针的前一个状态</td>
</tr>
<tr>
<td>packed-refs</td>
<td></td>
</tr>
</tbody>
</table>
<p>当更新一个引用时，git不会packed-refs，而是会在refs/heads下写入一个新文件。当查找一个引用时，git首先在refs目录下查找，如果未找到则到packed-refs文件中去查找</p>
<h5 id="从一个服务器克隆一个现有的Git仓库"><a href="#从一个服务器克隆一个现有的Git仓库" class="headerlink" title="从一个服务器克隆一个现有的Git仓库"></a>从一个服务器克隆一个现有的Git仓库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone [url]</span><br></pre></td></tr></table></figure>
<p>==Git克隆的是该Git仓库服务器上的几乎所有数据==<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone ../../test</span><br></pre></td></tr></table></figure></p>
<p>上命令会在当前目录下创建一个名为test的目录，并在这个目录下<strong>初始化一个.git文件夹</strong>，然后从中读取最新版本的文件的拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//本地文件夹名为 name</span><br><span class="line">git clone [url] name</span><br></pre></td></tr></table></figure>
<h4 id="记录更新到仓库"><a href="#记录更新到仓库" class="headerlink" title="记录更新到仓库"></a>记录更新到仓库</h4><p>工作目录下的每个文件都不外乎两种状态：已跟踪和未跟踪。</p>
<p>已跟踪文件:</p>
<ul>
<li>被纳入了版本控制的文件</li>
<li>在上一次快照中有记录</li>
<li>状态可能处于未修改、已修改或已放入暂存区</li>
</ul>
<p>为跟踪文件：</p>
<ul>
<li>除已跟踪文件外的所有文件</li>
</ul>
<p>使用Git时文件的生命周期：<br><img src="https://progit.bootcss.com/images/lifecycle.png" alt="image"></p>
<h5 id="检查当前文件状态"><a href="#检查当前文件状态" class="headerlink" title="检查当前文件状态"></a>检查当前文件状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br><span class="line"></span><br><span class="line">//状态简揽</span><br><span class="line">git status -s</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>??</td>
<td>未跟踪</td>
</tr>
<tr>
<td>A</td>
<td>新添加到暂存区的文件</td>
</tr>
<tr>
<td>M</td>
<td>修改过的文件</td>
</tr>
<tr>
<td>MM</td>
<td>文件修改且已放入暂存区（左M），文件修改后未放入暂存区（右M）</td>
</tr>
</tbody>
</table>
<h5 id="跟踪新文件"><a href="#跟踪新文件" class="headerlink" title="跟踪新文件"></a>跟踪新文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add [file]</span><br></pre></td></tr></table></figure>
<p>此时再运行git status查看文件状态。</p>
<h5 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h5><p>无需纳入Git管理，也不希望出现在未跟踪文件列表的文件。</p>
<p>创建.gitignore文件，列出要忽略的文件模式</p>
<h5 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br></pre></td></tr></table></figure>
<p>提价更新前要确认是否所有需更新文件都有git add。<br>每次准备提交前，先用git status查看文件是否已暂存，然后再提交。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &quot;提交信息&quot;</span><br></pre></td></tr></table></figure>
<p>==提交时记录的是放在<strong>暂存区域的快照</strong>==。</p>
<p>跳过使用暂存区域:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure></p>
<p>提交后，Git终端会显示的信息：</p>
<ul>
<li>提交的分支</li>
<li>提交的完整SHA-1校验和</li>
<li>修改过的文件和行信息</li>
</ul>
<h5 id="移除文件"><a href="#移除文件" class="headerlink" title="移除文件"></a>移除文件</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm [file_name]</span><br></pre></td></tr></table></figure>
<p>强制删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -f [file_name]</span><br></pre></td></tr></table></figure></p>
<p>把文件从Git仓库中删除（亦即从暂存区域移除），但仍保留在当前工作目录中。即让文件保留在磁盘，但是并不让Git继续跟踪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached [file_name]</span><br></pre></td></tr></table></figure></p>
<h5 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure>
<h5 id="撤销对文件的修改"><a href="#撤销对文件的修改" class="headerlink" title="撤销对文件的修改"></a>撤销对文件的修改</h5><p>命令行输入git status有提示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- [file]</span><br></pre></td></tr></table></figure></p>
<h5 id="推送到远程仓库"><a href="#推送到远程仓库" class="headerlink" title="推送到远程仓库"></a>推送到远程仓库</h5><p>将master分支推送到origin服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure></p>
<h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><h4 id="分支简介"><a href="#分支简介" class="headerlink" title="分支简介"></a>分支简介</h4><p>Git保存的不是文件的变化，而是一系列不同时刻的文件快照。</p>
<p>在进行提交操作时，Git会保存一个提交对象，该提交对象会包含一个指向暂时内容快照的指针（该提交对象还包含了作者的姓名、邮箱、提交时输入的信息以及指向它的父对象的指针）。首次提交的对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p>
<p>Git的分支，本质上是<strong>指向提交对象的==可变指针==</strong>。</p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h4><p>Git创建新分支只是创建了一个可以移动的新指针。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//创建名为testing的分支</span><br><span class="line">git branch testing</span><br></pre></td></tr></table></figure>
<p>这会在当前所在的提交对象上创建一个指针。</p>
<p>==Git中有一个名为HEAD的特殊指针，指向当前所在的本地分支==。git branch命令仅仅创建一个分支，并不会自动切换到新分支中去。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查看各个分支当前所指的对象</span><br><span class="line">git lot --oneline --decorate</span><br></pre></td></tr></table></figure>
<h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//切换到testing分支</span><br><span class="line">git checkout testing</span><br></pre></td></tr></table></figure>
<p>切换分支会使HEAD指向分支（testing），并且将工作目录恢复成分支（testing）所指向的快照内容。<br>在切换分支时，工作目录里的文件会被改变。如果是切换到一个较旧的分支，工作目录会恢复到该分支最后一次提交时的样子。如果Git不能干净利落地完成这个任务，它将禁止切换分支。</p>
<h5 id="分叉历史"><a href="#分叉历史" class="headerlink" title="分叉历史"></a>分叉历史</h5><p>输出提交历史、各个分支的指向以及项目分支分叉情况：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --oneline --decorate --graph --all</span><br></pre></td></tr></table></figure></p>
<p>Git分支实质上仅是包含所指对象校验和的文件。</p>
<h4 id="分支的新建与合并"><a href="#分支的新建与合并" class="headerlink" title="分支的新建与合并"></a>分支的新建与合并</h4><h5 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//新建issue分支，并切换到该分支</span><br><span class="line">git checkout -b issue</span><br></pre></td></tr></table></figure>
<h5 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//删除issue分支</span><br><span class="line">git branch -d issue</span><br></pre></td></tr></table></figure>
<h5 id="分支的合并"><a href="#分支的合并" class="headerlink" title="分支的合并"></a>分支的合并</h5><p>若合并分支issue到master<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git merge issue</span><br></pre></td></tr></table></figure></p>
<h5 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h5><p>查看分支列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch</span><br></pre></td></tr></table></figure></p>
<p>查看每一分支最后一次提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure></p>
<p>查看已合并分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --merged</span><br></pre></td></tr></table></figure></p>
<p>查看未合并分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch --no-merged</span><br></pre></td></tr></table></figure></p>
<p>新建和合并分支的时候，所有操作只发生在本地的Git版本库中，没有与服务器发生交互。</p>
<h4 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h4><p>远程引用是对远程仓库的引用（指针），包括分支、标签等。</p>
<h5 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h5><p>当git fetch命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。</p>
<p>如果有设置好的跟踪分支，git pull会查找当前分支所跟踪的服务器与分支，从服务器上抓取数据然后尝试合并入那个远程分支。</p>
<h5 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h5><p>从服务器上删除serverfix分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --delete serverfix</span><br></pre></td></tr></table></figure></p>
<h4 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h4><p>在Git中整合来自不同分支的修改方法：==merge和rebase==。</p>
<h5 id="Git钩子"><a href="#Git钩子" class="headerlink" title="Git钩子"></a>Git钩子</h5><p>Git能在特定的重要动作发生时触发自定义脚本，有两组这样的钩子：客户端和服务端。</p>
<ul>
<li>客户端钩子由提交和合并等操作调用</li>
<li>服务端钩子作用于诸如接受被推送的提交的联网操作</li>
</ul>
<h4 id="Git内部原理"><a href="#Git内部原理" class="headerlink" title="Git内部原理"></a>Git内部原理</h4><h5 id="底层命令和高层命令"><a href="#底层命令和高层命令" class="headerlink" title="底层命令和高层命令"></a>底层命令和高层命令</h5><p>.git目录初始默认结构：</p>
<table>
<thead>
<tr>
<th>文件（夹）</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>HEAD</td>
<td>指示目前被检出的分支</td>
</tr>
<tr>
<td>config</td>
<td>包含项目特有的配置选项</td>
</tr>
<tr>
<td>info/</td>
<td>包含一个全局性排除文件，用以放置不希望被记录在.gitignore文件中的忽略模式</td>
</tr>
<tr>
<td>hooks/</td>
<td>包含客户端或服务端的钩子脚本</td>
</tr>
<tr>
<td>objects/</td>
<td>存储所有数据内容</td>
</tr>
<tr>
<td>refs/</td>
<td>存储指向数据（分支）的提交对象的指针</td>
</tr>
<tr>
<td>index</td>
<td>保存暂存区信息</td>
</tr>
</tbody>
</table>
<h5 id="Git对象"><a href="#Git对象" class="headerlink" title="Git对象"></a>Git对象</h5>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/06/08/js继承的几种方式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="张倩倩">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hermione">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/js继承的几种方式/" itemprop="url">js继承的几种方式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T17:09:21+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="1-原型链"><a href="#1-原型链" class="headerlink" title="1. 原型链"></a>1. 原型链</h3><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>将原型对象的指针指向另一个类的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">   this.name = &quot;SuperType&quot;;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var sub = new SubType();</span><br><span class="line">console.log(sub.getSuperName());</span><br></pre></td></tr></table></figure></p>
<h5 id="注意使用"><a href="#注意使用" class="headerlink" title="注意使用"></a>注意使用</h5><ul>
<li>用原型链实现继承时，<strong>==不能使用对象字面量创建原型方法==</strong>，这样会重写原型链。如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">   this.name = &quot;SuperType&quot;;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">function SubType() &#123;</span><br><span class="line">    type : &quot;SubType&quot;,</span><br><span class="line">    getSubName : function() &#123;</span><br><span class="line">        return this.type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>若子类要覆盖超类中的方法，或添加自己的方法，添加方法的代码要放在替换原型的语句之后。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">   this.name = &quot;SuperType&quot;;</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">//原型链继承</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">//添加方法需放在原型继承语句之后</span><br><span class="line">SubType.prototype.getSubName = function() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h5><ul>
<li>若包含引用类型，不可通过原型链的方式来实现继承。原型中定义的属性和方法会在所有实例中共享。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">   this.name = [&quot;s&quot;, &quot;u&quot;, &quot;p&quot;, &quot;e&quot;, &quot;r&quot;];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.getSuperName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line"></span><br><span class="line">var sub1 = new SubType();</span><br><span class="line">sub1.name.push(&quot;sub&quot;);</span><br><span class="line">console.log(sub1.getSuperName());       //[ &apos;s&apos;, &apos;u&apos;, &apos;p&apos;, &apos;e&apos;, &apos;r&apos;, &apos;sub&apos; ]</span><br><span class="line"></span><br><span class="line">var sub2 = new SubType();</span><br><span class="line">console.log(sub2.getSuperName());       //[ &apos;s&apos;, &apos;u&apos;, &apos;p&apos;, &apos;e&apos;, &apos;r&apos;, &apos;sub&apos; ]</span><br></pre></td></tr></table></figure>
<ul>
<li>在创建子类实例时，不可向超类构造函数传递参数。</li>
</ul>
<h3 id="2-借用构造函数"><a href="#2-借用构造函数" class="headerlink" title="2. 借用构造函数"></a>2. 借用构造函数</h3><ul>
<li><h5 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h5>当原型中包含引用类型时，借用构造函数每个实例都有其父类属性的副本，并不是共享所有属性。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function SuperType() &#123;</span><br><span class="line">    this.name = [&quot;s&quot;, &quot;u&quot;, &quot;p&quot;, &quot;e&quot;, &quot;r&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType() &#123;</span><br><span class="line">    //调用超类构造函数实现继承</span><br><span class="line">    SuperType.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub = new SubType();</span><br><span class="line">console.log(sub.name);</span><br></pre></td></tr></table></figure>
<p><strong>借用构造函数可向父类构造函数中传递参数。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(type) &#123;</span><br><span class="line">    this.name = [&quot;s&quot;, &quot;u&quot;, &quot;p&quot;, &quot;e&quot;, &quot;r&quot;];</span><br><span class="line">    this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(type) &#123;</span><br><span class="line">    SuperType.call(this, type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line"></span><br><span class="line">var sub1 = new SubType(&quot;SubType&quot;);</span><br><span class="line">console.log(sub1.getName());</span><br></pre></td></tr></table></figure>
<ul>
<li><h5 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h5>借用构造函数方式，方法都在构造函数中定义，<strong>无法实现函数复用</strong>。</li>
</ul>
<h3 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3. 组合继承"></a>3. 组合继承</h3><ul>
<li><h5 id="改进-1"><a href="#改进-1" class="headerlink" title="改进"></a>改进</h5>将原型链与借用构造函数方法结合。使用原型链实现对原型属性和方法的继承，借用构造函数实现对实例属性的继承。<strong>函数复用</strong>得以实现。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function SuperType(type) &#123;</span><br><span class="line">    this.name = [&quot;s&quot;, &quot;u&quot;, &quot;p&quot;, &quot;e&quot;, &quot;r&quot;];</span><br><span class="line">    this.type = type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getType = function() &#123;</span><br><span class="line">    return this.type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(name) &#123;</span><br><span class="line">    //继承共有属性</span><br><span class="line">    SuperType.call(this, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SubType.prototype = new SuperType();</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">//实例共用的方法</span><br><span class="line">SubType.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var sub1 = new SubType(&quot;sub1&quot;);</span><br><span class="line">sub1.name.push(&quot;sub&quot;);</span><br><span class="line">console.log(sub1.getType());</span><br><span class="line">console.log(sub1.getName());</span><br><span class="line"></span><br><span class="line">var sub2 =new SubType(&quot;sub2&quot;);</span><br><span class="line">console.log(sub2.getType());</span><br><span class="line">console.log(sub2.getName());</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点</li>
</ul>
<p>组合继承会调用两次超类构造函数。</p>
<h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4. 原型式继承"></a>4. 原型式继承</h3><p>借助原型，基于已有对象创建新对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function object(obj) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype = obj;</span><br><span class="line">    return new F();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;zhangsan&quot;,</span><br><span class="line">    array: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj1 = new object(person);</span><br><span class="line">obj1.array.push(4);</span><br><span class="line">console.log(obj1.name);             //zhangsan</span><br><span class="line">console.log(obj1.array);            //[ 1, 2, 3, 4 ]</span><br><span class="line"></span><br><span class="line">var obj2 = new object(person);</span><br><span class="line">console.log(obj2.name);             //zhangsan</span><br><span class="line">console.log(obj2.array);            //[ 1, 2, 3, 4 ]</span><br></pre></td></tr></table></figure>
<p>ECMAScript5 新增Object.create()方法规范原型式继承。</p>
<h5 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h5><ul>
<li>所有子类实例<strong>共享</strong>父类属性</li>
<li>无法实现函数复用</li>
</ul>
<h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5. 寄生式继承"></a>5. 寄生式继承</h3><p>创建一个仅用于封装继承过程的函数，在函数内部以某种方式增强对象，后返回该对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function createObj(obj) &#123;</span><br><span class="line">    var clone = Object.create(obj);</span><br><span class="line">    clone.greet = function() &#123;</span><br><span class="line">        console.log(&quot;hi&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line">    return clone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;zhangsan&quot;,</span><br><span class="line">    array: [1, 2, 3]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj = createObj(person);</span><br></pre></td></tr></table></figure>
<ul>
<li>缺点</li>
</ul>
<p>未实现函数复用</p>
<h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6. 寄生组合式继承"></a>6. 寄生组合式继承</h3><ul>
<li>通过借用构造函数来继承属性，通过原型链的混合形式来继承方法。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function inherPrototype(subType, superType) &#123;</span><br><span class="line">    var prototype = Object.create(superType.prototype);</span><br><span class="line">    prototype.constructor = subType;</span><br><span class="line">    subType.prototype = prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SuperType(type) &#123;</span><br><span class="line">    this.type = type;</span><br><span class="line">    this.name = [&quot;s&quot;, &quot;u&quot;, &quot;p&quot;, &quot;e&quot;, &quot;r&quot;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getType = function() &#123;</span><br><span class="line">    return this.type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function SubType(type, name) &#123;</span><br><span class="line">    SuperType.call(this, type);</span><br><span class="line"></span><br><span class="line">    this.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inherPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.getName = function() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>改进</li>
</ul>
<p>仅调用一次超类构造函数。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">张倩倩</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张倩倩</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
